<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Стас: Гнев Потопа</title>
    <style>
        body {
            margin: 0; display: flex; justify-content: center; align-items: center;
            height: 100vh; background-color: #333;

            /* НОВОЕ: Мобильное управление */
            #mobile-controls {
                display: none; /* Скрыто по умолчанию, включается через JS */
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 120px; /* Область для кнопок */
                z-index: 25;
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
            }
            .mobile-btn {
                position: absolute;
                bottom: 20px;
                width: 80px;
                height: 80px;
                background-color: rgba(255, 255, 255, 0.25);
                border: 2px solid rgba(255, 255, 255, 0.4);
                border-radius: 50%;
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 36px;
                color: rgba(255, 255, 255, 0.9);
                text-shadow: 1px 1px 3px black;
                cursor: pointer;
            }
            #left-btn { left: 30px; }
            #right-btn { right: 30px; }
            .mobile-btn:active {
                background-color: rgba(255, 255, 255, 0.45);
            }
            /* --- Конец мобильного управления --- */

            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            flex-direction: column; color: white;
        }
        h1 { text-shadow: 2px 2px 4px #000; }
        #game-container {
            width: 500px; height: 700px; border: 2px solid #ccc;
            position: relative; overflow: hidden; background-color: #87CEEB;
        }
        /* НОВОЕ: Анимация тряски экрана */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .screen-shake {
            animation: shake 0.5s linear;
        }
        #parallax-bg {
            position: absolute; width: 100%; height: 1400px; top: 0; left: 0; z-index: 1;
            background-image:
                radial-gradient(circle at 15% 30%, white 30px, transparent 31px),
                radial-gradient(circle at 75% 20%, white 50px, transparent 51px),
                radial-gradient(circle at 40% 80%, white 40px, transparent 41px),
                radial-gradient(circle at 80% 95%, white 35px, transparent 36px),
                radial-gradient(circle at 50% 50%, white 60px, transparent 61px);
            background-color: #87CEEB;
        }
        #stas {
            position: absolute; width: 40px; height: 60px;
            background-color: #4169E1; z-index: 10; border-radius: 5px;
        }
        .platform {
            position: absolute; width: 100px; height: 20px;
            z-index: 5; border-radius: 4px; transition: opacity 0.3s, transform 0.3s;
        }
        .platform-normal { background-color: #228B22; border-bottom: 3px solid #1c6b1c; }
        .platform-breaking { background-color: #A0522D; border-bottom: 3px solid #8B4513; }
        .platform-bouncy { background-color: #48D1CC; border-bottom: 3px solid #20B2AA; }
        #water {
            position: absolute; width: 100%;
            background: linear-gradient(to top, #503010, #654321);
            bottom: 0; left: 0; z-index: 8; opacity: 0.9;
            transition: height 0.2s linear;
        }
        /* НОВОЕ: Пена на воде для большей динамики */
        #water::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 0;
            width: 100%;
            height: 10px;
            background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(255,255,255,0.2), rgba(255,255,255,0.5));
            border-radius: 50%;
            filter: blur(2px);
        }
        #score-panel {
            position: absolute; top: 10px; left: 10px;
            font-size: 24px; color: white; z-index: 20;
            text-shadow: 2px 2px 4px black; background-color: rgba(0,0,0,0.2);
            padding: 5px 10px; border-radius: 5px;
        }
        #score, #water-level-display { line-height: 1.2; }
        #water-level-display { font-size: 16px; color: #ffcccc; }
        #game-over {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); display: none;
            flex-direction: column; align-items: center;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 30px; border-radius: 10px; z-index: 30;
            text-align: center; color: #333; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #game-over h2 { margin: 0 0 10px 0; color: #a52a2a; }
        #high-score { font-size: 18px; color: #333; margin-top: 10px; }
        #restart-button {
            padding: 10px 20px; font-size: 18px; cursor: pointer;
            border: none; background-color: #4CAF50; color: white;
            border-radius: 5px; margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Стас: Гнев Потопа</h1>
    <div id="game-container">
        <div id="mobile-controls">
            <div id="left-btn" class="mobile-btn">◀</div>
            <div id="right-btn" class="mobile-btn">▶</div>
        </div>
        <div id="parallax-bg"></div><div id="stas"></div><div id="water"></div>
        <div id="score-panel">
            <div id="score">Высота: 0.0м</div>
            <div id="water-level-display">Вода: 0.0м</div>
        </div>
        <div id="game-over">
            <h2>Потоп одолел!</h2>
            <p id="final-score"></p><p id="high-score"></p>
            <button id="restart-button">Попробовать снова</button>
        </div>
    </div>
    <div id="desktop-controls">
      <p><b>Управление:</b> ← → для движения, <b>Пробел</b> для прыжка.</p>
    </div>
    <p id="mobile-instructions" style="display: none;"><b>Управление:</b> кнопки ◀ ▶ для движения, тап по экрану для прыжка.</p>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const gameContainer = document.getElementById('game-container');
        const parallaxBg = document.getElementById('parallax-bg');
        const stas = document.getElementById('stas'), water = document.getElementById('water');
        const scoreDisplay = document.getElementById('score'), waterLevelDisplay = document.getElementById('water-level-display');
        const gameOverScreen = document.getElementById('game-over'), finalScoreDisplay = document.getElementById('final-score'), highScoreDisplay = document.getElementById('high-score');
        const restartButton = document.getElementById('restart-button');
        // НОВОЕ: Элементы управления
        const mobileControls = document.getElementById('mobile-controls');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const desktopControls = document.getElementById('desktop-controls');
        const mobileInstructions = document.getElementById('mobile-instructions');

        const gameWidth = 500, gameHeight = 700;
        const stasWidth = 40, stasHeight = 60;
        const PIXELS_PER_METER = 100;

        let playerX, playerY, velocityY, isJumping, score, totalScrolledHeight, waterLevel, waterSpeed, waterAcceleration, backgroundY, highScore;
        let surgeCooldown, surgeActive;
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            if(type === 'jump') { oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(300, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0.1, audioCtx.currentTime + 0.02); oscillator.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1); }
            else if (type === 'bounce') { oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(400, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.02); oscillator.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.2); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2); }
            else if (type === 'gameOver') { oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(200, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.02); oscillator.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.5); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5); }
            else if (type === 'surge') { oscillator.type = 'square'; oscillator.frequency.setValueAtTime(100, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.02); oscillator.frequency.linearRampToValueAtTime(40, audioCtx.currentTime + 1); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1); }
            oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + 1);
        }
        
        const keys = { ArrowLeft: false, ArrowRight: false };
        let platforms = [], gameLoopInterval;

        function initGameVariables() {
            playerX = gameWidth / 2 - stasWidth / 2;
            playerY = 50; velocityY = 0; isJumping = false; score = 0;
            totalScrolledHeight = 0; waterLevel = 0; backgroundY = 0;
            highScore = localStorage.getItem('stasHighScore') || 0;
            waterSpeed = 0.4;
            waterAcceleration = 0.0004;
            surgeCooldown = 500;
            surgeActive = 0;
        }

        const gravity = -0.7, jumpPower = 18, moveSpeed = 7;
        const bouncePower = 30;

        function createPlatform(y) {
            const platform = document.createElement('div');
            platform.classList.add('platform');
            const rand = Math.random();
            if (rand < 0.15 && y > 300) { platform.classList.add('platform-breaking'); platform.dataset.type = 'breaking'; }
            else if (rand < 0.25) { platform.classList.add('platform-bouncy'); platform.dataset.type = 'bouncy'; }
            else { platform.classList.add('platform-normal'); platform.dataset.type = 'normal'; }
            platform.style.bottom = y + 'px'; platform.style.left = Math.random() * (gameWidth - 100) + 'px';
            gameContainer.appendChild(platform); platforms.push(platform);
        }

        function generateInitialPlatforms() {
            platforms.forEach(p => p.remove()); platforms = [];
            const startPlatform = document.createElement('div');
            startPlatform.classList.add('platform', 'platform-normal'); startPlatform.dataset.type = 'normal';
            startPlatform.style.bottom = '50px'; startPlatform.style.left = (gameWidth / 2 - 50) + 'px';
            gameContainer.appendChild(startPlatform); platforms.push(startPlatform);
            for (let i = 150; i < gameHeight; i += 120) createPlatform(i);
        }

        function updateGame() {
            if (keys.ArrowLeft) playerX -= moveSpeed; if (keys.ArrowRight) playerX += moveSpeed;
            if (playerX < 0) playerX = 0; if (playerX > gameWidth - stasWidth) playerX = gameWidth - stasWidth;
            velocityY += gravity; playerY += velocityY;
            isJumping = true;
            platforms.forEach(platform => {
                const platBottom = parseInt(platform.style.bottom), platLeft = parseInt(platform.style.left);
                if (velocityY < 0 && playerY < platBottom + 20 && playerY + stasHeight > platBottom && playerX + stasWidth > platLeft && playerX < platLeft + 100) {
                    switch (platform.dataset.type) {
                        case 'bouncy': velocityY = bouncePower; playSound('bounce'); break;
                        case 'breaking': velocityY = jumpPower; platform.dataset.type = 'broken'; setTimeout(() => { platform.style.opacity = '0'; platform.style.transform = 'translateY(20px)'; setTimeout(() => platform.remove(), 300); }, 100); break;
                        default: velocityY = jumpPower; break;
                    }
                    playerY = platBottom + 20; isJumping = false;
                }
            });
            platforms = platforms.filter(p => p.parentElement);

            if (playerY > gameHeight / 2) {
                const shift = playerY - gameHeight / 2;
                totalScrolledHeight += shift;
                playerY -= shift; waterLevel -= shift; backgroundY -= shift * 0.5;
                platforms.forEach(platform => {
                   let newBottom = parseInt(platform.style.bottom) - shift;
                   if (newBottom < -20) platform.remove();
                   else platform.style.bottom = newBottom + 'px';
                });
                platforms = platforms.filter(p => p.parentElement);
                const lastPlatformY = Math.max(0, ...platforms.map(p => parseInt(p.style.bottom)));
                if (lastPlatformY < gameHeight - 100) createPlatform(lastPlatformY + 100 + Math.random() * 50);
            }

            surgeCooldown--;
            if (surgeCooldown <= 0) {
                surgeActive = 50;
                playSound('surge');
                gameContainer.classList.add('screen-shake');
                surgeCooldown = 400 + Math.random() * 400;
            }
            if (surgeActive > 0) {
                surgeActive--;
                waterSpeed += 0.2;
                if (surgeActive === 0) {
                    gameContainer.classList.remove('screen-shake');
                }
            }

            waterLevel += waterSpeed; waterSpeed += waterAcceleration;
            water.style.height = `${waterLevel}px`;
            
            let currentHeight = totalScrolledHeight + playerY; score = Math.max(score, currentHeight);
            scoreDisplay.textContent = `Высота: ${(score / PIXELS_PER_METER).toFixed(1)}м`;
            let realWaterHeight = totalScrolledHeight + waterLevel;
            waterLevelDisplay.textContent = `Вода: ${(realWaterHeight / PIXELS_PER_METER).toFixed(1)}м`;

            stas.style.left = playerX + 'px'; stas.style.bottom = playerY + 'px';
            parallaxBg.style.transform = `translateY(${backgroundY}px)`;

            if (playerY < waterLevel || playerY < -stasHeight) gameOver();
        }
        
        function gameOver() {
            clearInterval(gameLoopInterval); playSound('gameOver');
            const finalScoreMeters = (score / PIXELS_PER_METER).toFixed(1);
            finalScoreDisplay.textContent = `Ваш результат: ${finalScoreMeters}м`;
            if (score > highScore) { highScore = score; localStorage.setItem('stasHighScore', highScore); highScoreDisplay.textContent = `НОВЫЙ РЕКОРД!`; }
            else { highScoreDisplay.textContent = `Рекорд: ${(highScore / PIXELS_PER_METER).toFixed(1)}м`; }
            gameOverScreen.style.display = 'flex';
        }

        function handleKeyDown(e) { if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') keys[e.code] = true; if (e.code === 'Space' && !isJumping) { velocityY = jumpPower; playSound('jump'); } }
        function handleKeyUp(e) { if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') keys[e.code] = false; }
        
        // НОВОЕ: Функция настройки мобильного управления
        function setupMobileControls() {
            const isTouchDevice = 'ontouchstart' in window;
            if (!isTouchDevice) return;
            
            mobileControls.style.display = 'block';
            desktopControls.style.display = 'none';
            mobileInstructions.style.display = 'block';

            const handleMove = (e, isStarting) => {
                e.preventDefault();
                const targetId = e.currentTarget.id;
                if (targetId === 'left-btn') keys.ArrowLeft = isStarting;
                if (targetId === 'right-btn') keys.ArrowRight = isStarting;
            };

            leftBtn.addEventListener('touchstart', e => handleMove(e, true), { passive: false });
            leftBtn.addEventListener('touchend', e => handleMove(e, false), { passive: false });
            rightBtn.addEventListener('touchstart', e => handleMove(e, true), { passive: false });
            rightBtn.addEventListener('touchend', e => handleMove(e, false), { passive: false });

            gameContainer.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('mobile-btn')) return;
                e.preventDefault();
                if (!isJumping) {
                    velocityY = jumpPower;
                    playSound('jump');
                }
            }, { passive: false });
        }

        function startGame() {
            initGameVariables(); generateInitialPlatforms();
            gameOverScreen.style.display = 'none';
            if(audioCtx.state === 'suspended') { audioCtx.resume(); }
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(updateGame, 20);
        }

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        restartButton.addEventListener('click', startGame);

        setupMobileControls(); // Вызываем настройку мобильного управления
        startGame();
    });
    </script>
</body>
</html>
